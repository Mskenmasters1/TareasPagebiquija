IMÁGENES
---------------------------------------------------------------------------------------
Creamos las carpeta assets y uploads dentro de dist. Dentro de assets, copiamos el archivo no-image.jpg 
npm install express-fileupload
npm install --save-dev @types/express-fileupload
npm install uuid
npm install --save-dev @types/uuid

---------------------------------------------------------------------------------------
En carpeta helpers, creamos el archivo subirArchivo.ts
---------------------------------------------------------------------------------------
--subirArchivo.ts

import fileUpload from 'express-fileupload';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

export const subirArchivo = (
  files: fileUpload.UploadedFile[] | fileUpload.UploadedFile,
  extensionesValidas = ['png', 'jpg', 'jpeg'],
  carpeta = ''
) => {
  return new Promise((resolve, reject) => {
    const archivo = files as fileUpload.UploadedFile;
    const nombreCortado = archivo.name.split('.');
    const extension = nombreCortado[nombreCortado.length - 1];
    // Validamos la extension
    if (!extensionesValidas.includes(extension)) {
      return reject(`La extensión ${extension} no es permitida - ${extensionesValidas}`);
    }

    const nombreTemp = uuidv4() + '.' + extension;
    const uploadPath = path.join(__dirname, '/../uploads/', carpeta, nombreTemp);

    archivo.mv(uploadPath, (err: any) => {
      if (err) {
        reject(err);
      }

      resolve(nombreTemp);
    });
  });
};

---------------------------------------------------------------------------------------
En carpeta controllers, creamos el archivo uploadsController.ts
---------------------------------------------------------------------------------------
--uploadsController.ts

import { Request, Response } from 'express';
import path from 'path';
import fs from 'fs';
import { subirArchivo } from '../helpers/subirArchivo';
import { Usuario } from '../models/usuario';
import { Producto } from '../models/producto';
import { IUsuario } from '../interfaces/usuario.interface';
import { Document } from 'mongoose';
import { IProducto } from '../interfaces/producto.interface';
import fileUpload from 'express-fileupload';

export const cargarArchivo = async (req: Request, res: Response) => {
  try {
    const archivo: fileUpload.FileArray = req.files!;
    const nombre = await subirArchivo(archivo['archivo'], undefined, 'imgs');
    // txt, md
    // const nombre = await subirArchivo( archivo['archivo'], ['txt','md'], 'textos' );
    res.json({ nombre });
  } catch (msg) {
    res.status(400).json({ msg });
  }
};

export const actualizarImagen = async (req: Request, res: Response) => {
  const { id, coleccion } = req.params;

  let modelo: Document<IProducto> | Document<IUsuario> | null;

  switch (coleccion) {
    case 'usuarios':
      modelo = await Usuario.findById(id);
      if (!modelo) {
        return res.status(400).json({
          msg: `No existe un usuario con el id ${id}`
        });
      }

      break;

    case 'productos':
      modelo = await Producto.findById(id);
      if (!modelo) {
        return res.status(400).json({
          msg: `No existe un producto con el id ${id}`
        });
      }

      break;

    default:
      return res.status(500).json({ msg: 'Colección incorrecta' });
  }

  // Limpiamos imágenes previas
  if (modelo.get('img')) {
    // Borramos la imagen del servidor
    const pathImagen = path.join(__dirname, '../uploads', coleccion, modelo.get('img'));
    if (fs.existsSync(pathImagen)) {
      fs.unlinkSync(pathImagen);
    }
  }

  try {
    const archivo: fileUpload.FileArray = req.files!;
    const nombre = await subirArchivo(archivo['archivo'], undefined, coleccion);
    modelo.set('img', nombre);

    await modelo.save();

    res.json(modelo);
  } catch (error) {
    return res.status(500).json({ msg: error });
  }
};

export const mostrarImagen = async (req: Request, res: Response) => {
  const { id, coleccion } = req.params;

  let modelo: Document<IProducto> | Document<IUsuario> | null;

  switch (coleccion) {
    case 'usuarios':
      modelo = await Usuario.findById(id);
      if (!modelo) {
        return res.status(400).json({
          msg: `No existe un usuario con el id ${id}`
        });
      }

      break;

    case 'productos':
      modelo = await Producto.findById(id);
      if (!modelo) {
        return res.status(400).json({
          msg: `No existe un producto con el id ${id}`
        });
      }

      break;

    default:
      return res.status(500).json({ msg: 'Validación pendiente' });
  }

  if (modelo.get('img')) {
    const pathImagen = path.join(__dirname, '/../uploads/', coleccion, modelo.get('img'));

    if (fs.existsSync(pathImagen)) {
      return res.sendFile(pathImagen);
    }
  }

  const pathImagen = path.join(__dirname, '../assets/no-image.jpg');
  res.sendFile(pathImagen);
};

---------------------------------------------------------------------------------------
En carpeta routes, creamos el archivo uploads.ts
---------------------------------------------------------------------------------------
--uploads.ts

import { Router } from 'express';
import { validarArchivoSubir } from '../middlewares/validarArchivo';
import { actualizarImagen, cargarArchivo, mostrarImagen } from '../controllers/uploadsController';
import { check } from 'express-validator';
import { coleccionesPermitidas } from '../helpers/dbValidators';
import { validarCampos } from '../middlewares';

export const routerUploads = Router();

routerUploads.post('/', validarArchivoSubir, cargarArchivo);

routerUploads.put(
  '/:coleccion/:id',
  [
    validarArchivoSubir,
    check('id', 'El id debe de ser de mongo').isMongoId(),
    check('coleccion').custom((x) => coleccionesPermitidas(x, ['usuarios', 'productos'])),
    validarCampos
  ],
  actualizarImagen
);

routerUploads.get(
  '/:coleccion/:id',
  [
    check('id', 'El id debe de ser de mongo').isMongoId(),
    check('coleccion').custom((x) => coleccionesPermitidas(x, ['usuarios', 'productos'])),
    validarCampos
  ],
  mostrarImagen
);

---------------------------------------------------------------------------------------
En carpeta middlewares, creamos el archivo validarArchivo.ts
---------------------------------------------------------------------------------------
--validarArchivo.ts

import { NextFunction, Request, Response } from 'express';

export const validarArchivoSubir = (req: Request, res: Response, next: NextFunction) => {
  if (!req.files || Object.keys(req.files).length === 0 || !req.files.archivo) {
    return res.status(400).json({
      msg: 'No hay archivos que subir - validarArchivoSubir'
    });
  }

  next();
};

---------------------------------------------------------------------------------------
--dbValidators.ts


export const coleccionesPermitidas = (coleccion = '', colecciones: string[] = []) => {
  const incluida = colecciones.includes(coleccion);
  if (!incluida) {
    throw new Error(`La colección ${coleccion} no es permitida, ${colecciones}`);
  }
  return true;
};

---------------------------------------------------------------------------------------
--index.ts

import express from 'express';
import { Express } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import fileUpload from 'express-fileupload';
import { dbConnection } from './database/config';
import { routerUsuarios } from './routes/usuarios';
import { routerAuth } from './routes/auth';
import { routerCategorias } from './routes/categorias';
import { routerProductos } from './routes/productos';
import { routerUploads } from './routes/uploads';

dotenv.config();

export const server: Express = express();

// Middlewares
server.use(express.static('public'));
server.use(cors());
server.use(express.json());
server.use(
  fileUpload({
    createParentPath: true // Para que cree la carpeta si no existe
  })
);

// Rutas
server.use('/api/auth', routerAuth);
server.use('/api/usuarios', routerUsuarios);
server.use('/api/categorias', routerCategorias);
server.use('/api/productos', routerProductos);
server.use('/api/uploads', routerUploads);

// Base de datos
dbConnection();

server.listen(process.env.PORT, () => {
  console.log('Servidor en ejecución en puerto ' + process.env.PORT);
});


